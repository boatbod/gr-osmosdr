#pragma once

// HydraSDR Real-to-Complex Decimation-by-2 FIR Filters
// For RAW ADC input ??? Direct I/Q output
// Digital Down Converter (DDC) Implementation

// Usage:
// Input: Real ADC samples x[n] at rate Fs
// Processing:
//   - Even samples x[0], x[2], x[4], ... ??? I filter ??? I[k]
//   - Odd samples  x[1], x[3], x[5], ... ??? Q filter ??? Q[k]
// Output: Complex samples (I[k] + j*Q[k]) at rate Fs/2

// Fast/Low-latency DDC filters
#define DDC_FAST_16_I_LEN   4
const float DDC_FAST_16_I[] =
{
    +0.000076372413541f,
    +0.278292082043086f,
    +0.689088175444801f,
    +0.032543370098572f
};

#define DDC_FAST_16_Q_LEN   4
const float DDC_FAST_16_Q[] =
{
    +0.032543370098572f,
    -0.689088175444801f,
    +0.278292082043086f,
    -0.000076372413541f
};

#define DDC_FAST_8_I_LEN   6
const float DDC_FAST_8_I[] =
{
    -0.000282020847828f,
    +0.014909934209795f,
    +0.334814871938571f,
    +0.534469002092119f,
    +0.118741195628454f,
    -0.002652983021110f
};

#define DDC_FAST_8_Q_LEN   6
const float DDC_FAST_8_Q[] =
{
    +0.000000000000000f,
    -0.333333333333333f,
    -0.166666666666667f,
    +0.166666666666667f,
    +0.333333333333333f,
    +0.000000000000000f
};

#define DDC_FAST_4_I_LEN   8
const float DDC_FAST_4_I[] =
{
    -0.000176400987244f,
    -0.007672943512059f,
    +0.050811196029229f,
    +0.334336227782121f,
    +0.454416428182580f,
    +0.171824520401627f,
    -0.000859979929962f,
    -0.002679047966292f
};

#define DDC_FAST_4_Q_LEN   8
const float DDC_FAST_4_Q[] =
{
    -0.014644351464435f,
    -0.002092050209205f,
    -0.302039748953975f,
    -0.181223849372385f,
    +0.181223849372385f,
    +0.302039748953975f,
    +0.002092050209205f,
    +0.014644351464435f
};

#define DDC_FAST_2_I_LEN   12
const float DDC_FAST_2_I[] =
{
    +0.000102292037842f,
    -0.000931844291348f,
    -0.014198459995405f,
    -0.013735731763558f,
    +0.104389696565632f,
    +0.322077189068807f,
    +0.390112805388035f,
    +0.213650694439445f,
    +0.025221638308655f,
    -0.021337776630137f,
    -0.005590044412932f,
    +0.000239541284965f
};

#define DDC_FAST_2_Q_LEN   12
const float DDC_FAST_2_Q[] =
{
    -0.006913248335336f,
    -0.000628477121394f,
    -0.046882686459936f,
    -0.015627562153312f,
    -0.250803015125846f,
    -0.179145010804176f,
    +0.179145010804176f,
    +0.250803015125846f,
    +0.015627562153312f,
    +0.046882686459936f,
    +0.000628477121394f,
    +0.006913248335336f
};

// Balanced performance DDC filters
#define DDC_BALANCED_16_I_LEN   6
const float DDC_BALANCED_16_I[] =
{
    -0.000295303394104f,
    +0.004677773656944f,
    +0.335331583721696f,
    +0.562018246432284f,
    +0.102874940305282f,
    -0.004607240722101f
};

#define DDC_BALANCED_16_Q_LEN   6
const float DDC_BALANCED_16_Q[] =
{
    +0.000000000000000f,
    -0.333333333333333f,
    -0.166666666666667f,
    +0.166666666666667f,
    +0.333333333333333f,
    +0.000000000000000f
};

#define DDC_BALANCED_8_I_LEN   8
const float DDC_BALANCED_8_I[] =
{
    -0.000082342723189f,
    -0.010304629431122f,
    +0.031009896641975f,
    +0.345567277237411f,
    +0.490310849785845f,
    +0.158143908083662f,
    -0.012187571823011f,
    -0.002457387771572f
};

#define DDC_BALANCED_8_Q_LEN   8
const float DDC_BALANCED_8_Q[] =
{
    -0.014644351464435f,
    -0.002092050209205f,
    -0.302039748953975f,
    -0.181223849372385f,
    +0.181223849372385f,
    +0.302039748953975f,
    +0.002092050209205f,
    +0.014644351464435f
};

#define DDC_BALANCED_4_I_LEN   10
const float DDC_BALANCED_4_I[] =
{
    +0.000061953623040f,
    -0.004248556632725f,
    -0.019746937286951f,
    +0.068096678506293f,
    +0.339117589456746f,
    +0.438011529885661f,
    +0.193840484749156f,
    -0.001494012294773f,
    -0.013227948624255f,
    -0.000410781382191f
};

#define DDC_BALANCED_4_Q_LEN   10
const float DDC_BALANCED_4_Q[] =
{
    +0.000000000000000f,
    -0.030560819660529f,
    -0.007640204915132f,
    -0.277079385254603f,
    -0.184719590169736f,
    +0.184719590169736f,
    +0.277079385254603f,
    +0.007640204915132f,
    +0.030560819660529f,
    +0.000000000000000f
};

#define DDC_BALANCED_2_I_LEN   16
const float DDC_BALANCED_2_I[] =
{
    -0.000025292346888f,
    +0.000977329750539f,
    +0.003849824048127f,
    -0.004758031642674f,
    -0.033494132041279f,
    -0.020862259940478f,
    +0.122266799045137f,
    +0.330433482104935f,
    +0.390115854414590f,
    +0.230910755090356f,
    +0.033035072268670f,
    -0.039268200653325f,
    -0.018271522290788f,
    +0.002387652585136f,
    +0.002549655996985f,
    +0.000153013610955f
};

#define DDC_BALANCED_2_Q_LEN   16
const float DDC_BALANCED_2_Q[] =
{
    -0.004353160180415f,
    -0.000290210678694f,
    -0.016716655218668f,
    -0.003857689665846f,
    -0.059809629391631f,
    -0.027186195178014f,
    -0.218129883573786f,
    -0.169656576112945f,
    +0.169656576112945f,
    +0.218129883573786f,
    +0.027186195178014f,
    +0.059809629391632f,
    +0.003857689665846f,
    +0.016716655218668f,
    +0.000290210678694f,
    +0.004353160180415f
};

// High precision DDC filters
#define DDC_PRECISION_2_I_LEN   24
const float DDC_PRECISION_2_I[] =
{
    +0.000053725659473f,
    +0.000313019268097f,
    -0.000472223078511f,
    -0.003135334446924f,
    -0.001720928647180f,
    +0.010199509729475f,
    +0.016823085960995f,
    -0.011933183791086f,
    -0.057421218528338f,
    -0.027549624904963f,
    +0.136430657174989f,
    +0.337048645223326f,
    +0.390961980780447f,
    +0.244071739348199f,
    +0.039682597260379f,
    -0.058330134481895f,
    -0.037233077090739f,
    +0.007691256051826f,
    +0.016284084025457f,
    +0.003173854756953f,
    -0.003579409290577f,
    -0.001735619063294f,
    +0.000188825816702f,
    +0.000187772267190f
};

#define DDC_PRECISION_2_Q_LEN   24
const float DDC_PRECISION_2_Q[] =
{
    -0.002391811633238f,
    -0.000103991810141f,
    -0.005105477861284f,
    -0.000729353980183f,
    -0.013541590797642f,
    -0.003563576525695f,
    -0.029435381641934f,
    -0.012120451264326f,
    -0.060143632936774f,
    -0.036086179762064f,
    -0.182421715551139f,
    -0.154356836235579f,
    +0.154356836235579f,
    +0.182421715551139f,
    +0.036086179762064f,
    +0.060143632936774f,
    +0.012120451264326f,
    +0.029435381641934f,
    +0.003563576525695f,
    +0.013541590797642f,
    +0.000729353980183f,
    +0.005105477861284f,
    +0.000103991810141f,
    +0.002391811633238f
};

// Unified filter for existing hydrasdr_set_conversion_filter_float32 API
// This interleaves I and Q coefficients for hardware processing

#define DDC_INTERLEAVED_DECIMATION_2_LEN   32
const float DDC_INTERLEAVED_DECIMATION_2[] =
{
    // Interleaved I/Q: [I0, Q0, I1, Q1, ...]
    -0.000025292346888f,  // I[0]
    -0.004353160180415f,  // Q[0]
    +0.000977329750539f,  // I[1]
    -0.000290210678694f,  // Q[1]
    +0.003849824048127f,  // I[2]
    -0.016716655218668f,  // Q[2]
    -0.004758031642674f,  // I[3]
    -0.003857689665846f,  // Q[3]
    -0.033494132041279f,  // I[4]
    -0.059809629391631f,  // Q[4]
    -0.020862259940478f,  // I[5]
    -0.027186195178014f,  // Q[5]
    +0.122266799045137f,  // I[6]
    -0.218129883573786f,  // Q[6]
    +0.330433482104935f,  // I[7]
    -0.169656576112945f,  // Q[7]
    +0.390115854414590f,  // I[8]
    +0.169656576112945f,  // Q[8]
    +0.230910755090356f,  // I[9]
    +0.218129883573786f,  // Q[9]
    +0.033035072268670f,  // I[10]
    +0.027186195178014f,  // Q[10]
    -0.039268200653325f,  // I[11]
    +0.059809629391632f,  // Q[11]
    -0.018271522290788f,  // I[12]
    +0.003857689665846f,  // Q[12]
    +0.002387652585136f,  // I[13]
    +0.016716655218668f,  // Q[13]
    +0.002549655996985f,  // I[14]
    +0.000290210678694f,  // Q[14]
    +0.000153013610955f,  // I[15]
    +0.004353160180415f,  // Q[15]
};

// Implementation notes:
// 1. Input: Real ADC samples at rate Fs
// 2. Polyphase processing:
//    - Branch 0 (I): x[0], x[2], x[4], ... * I_coeffs
//    - Branch 1 (Q): x[1], x[3], x[5], ... * Q_coeffs
// 3. Output: Complex samples at rate Fs/2
// 4. Q channel provides 90-degree phase shift for proper I/Q

// Filter selection guide:
// - Use DDC_FAST_* for low latency applications
// - Use DDC_BALANCED_* for general purpose
// - Use DDC_PRECISION_* for high dynamic range
// - Number suffix indicates effective decimation factor

